Overview

This repository contains a proof‑of‑concept back‑end for a subscription management system. The goal was to build a small, clean API in roughly an hour that demonstrates how I think about architecture and trade‑offs. The implementation uses .NET 8, Entity Framework Core, MediatR, and domain‑driven design patterns. The solution is structured into four independent projects:
	1.	Phoenix.Domain – holds the domain model (aggregate roots such as SubscriptionPlan and User, value objects, domain events, and enums).
	2.	Phoenix.Application – implements the CQRS pattern via MediatR commands, queries, and handlers; contains validation behavior, pipeline behaviors, and DTO mapping.
	3.	Phoenix.Infrastructure – provides data persistence with EF Core; includes separate write (ApplicationDbContext) and read‑only (ApplicationDbContextReadOnly) contexts, entity configurations, and migration scripts.
	4.	Phoenix.WebApi – exposes RESTful controllers and configures services (DI, EF Core, MediatR, Swagger, CORS, health checks).

This separation enforces a clean architecture: the domain layer knows nothing about application or infrastructure concerns; the application layer coordinates domain operations through commands/queries; infrastructure implements persistence behind interfaces; and the WebApi wires everything up without leaking business logic into controllers.

Why this structure and technologies

Clean Architecture & DDD: Keeping domain logic isolated makes it easy to unit‑test and prevents “anemic” models. The SubscriptionPlan aggregate encapsulates plan creation, update, and state transitions (Activate, Deactivate, MarkPending, etc.) and raises domain events to signal state changes. The User aggregate encapsulates user identity, current plan, and reserved plan logic. Each entity has value objects (e.g., Email) and uses ULIDs instead of GUIDs for lexicographically sortable identifiers.

Why use ULID:
ULID (Universally Unique Lexicographically Sortable Identifier) is used instead of GUIDs because it provides several advantages:
	•	Application-generated side: ULID is generated on the application side, unlike GUID, which is typically generated by the database. This approach avoids the performance penalty of generating GUIDs on the database side.
	•	Indexing capability: ULIDs can be indexed in databases because they are lexicographically sortable. This allows better optimization when using indexes, which is not possible with GUIDs.
	•	Better sorting: ULID is more efficient for sorting and range queries due to its lexicographical nature, which aligns with time-based sorting. GUIDs, on the other hand, do not have any inherent ordering.

Why Rich Domain Models are good:
In this solution, I’ve adopted rich domain models, where the domain entities not only hold data but also encapsulate business behavior. A rich model has several benefits:
	•	Encapsulation of business logic: A rich model makes it easy to express and enforce business rules directly in the domain. For example, the SubscriptionPlan aggregate contains logic for state transitions (Activate, Deactivate, MarkPending) and validation. This ensures that the state changes are always consistent with the rules of the system.
	•	Better maintainability and scalability: By encapsulating behavior within the domain model, you reduce the need for external logic, which makes the system easier to maintain. When business logic is encapsulated in the domain, it is easier to scale or refactor specific parts of the system.
	•	Improved testability: Since the business logic is in the domain model, it becomes easier to write unit tests for it. You can test the domain behavior independently of infrastructure or application logic, which leads to more reliable tests and easier debugging.
	•	Increased clarity: The rich model leads to clearer code that more accurately reflects the real-world business processes. It ensures that business rules and decisions are centralized and consistently applied across the system.

Domain configurations define table schema via EF Core; for example, SubscriptionPlanConfiguration maps the title, description, price as an owned type and status fields, and stores plans in a SubscriptionPlans table. UserConfiguration maps the email value object and defines foreign keys to current and reserved plans.

CQRS with MediatR: Commands and queries are decoupled via MediatR. Each controller action simply constructs a command/query and delegates to the MediatR pipeline. Pipeline behaviors enforce validation (ValidationBehavior uses FluentValidation), logging, and exception handling. The SubscriptionPlanController exposes endpoints such as POST /api/SubscriptionPlan/create, PUT /api/SubscriptionPlan/{id}/activate, and GET /api/SubscriptionPlan without embedding any domain logic.

EF Core & Migrations: ApplicationDbContext sets the default schema and applies all configurations from the infrastructure assembly. Two contexts are registered: a write context with tracking and a read‑only context with QueryTrackingBehavior.NoTracking, which enables future scaling through read replicas. The context overrides SaveChanges to normalize Persian characters (Fa2En and FixPersianChars) before persisting. Migrations create the SubscriptionPlans and Users tables with proper keys and relationships. Connection strings can be configured for separate read/write databases, and retries/timeouts are enabled.

Service registration and middleware: The Web API registers MediatR, EF Core, and other services via a single AddServices extension. It configures Swagger, CORS, and health checks, and applies a custom exception handler. During startup, the API automatically applies pending migrations via ApplicationDbContextInitializer.

Package Version Management via Directory.Packages.props:
To centralize package version management and prevent conflicts between different versions of packages, I have used Directory.Packages.props. This allows all projects to reference the same versions of packages, ensuring consistency and avoiding version conflicts across the solution. It simplifies dependency management and reduces the potential for errors caused by incompatible versions.

Scaling and improvements for a production system

The current implementation is intentionally minimal; several areas would need to evolve for a real‑world system:
• Persistence: The code targets SQL Server via EF Core. Read/write separation is already in place; further scaling could add read replicas and event sourcing for audit trails.
• Domain events processing: Domain events are raised but not handled; in a production system, you’d implement asynchronous event handlers to send emails, publish messages, or update projections. A background service (hosted in the infrastructure layer) could listen to a queue and process events.
• Validation & error handling: FluentValidation is used for commands, but there are no tests. Comprehensive unit/integration tests should be added. Error messages and localization should be improved. Currently, the API returns generic 200 OK responses even when creating/deleting resources; adopting proper REST semantics (e.g., 201 Created with a Location header) would make the API more idiomatic.

API documentation: Swagger UI is enabled in development. To support multiple versions and clients, you’d document request/response schemas and use versioning (e.g., URL or header‑based versioning).

Time spent

Approximately 1 day were spent designing, coding, reading through the domain, application, and API layers, and writing this README. The time includes understanding the requirements, setting up the solution, implementing commands/queries, configuring EF Core, and writing a thorough explanation.

AI usage

I wrote all domain and application code manually. AI assistance (such as ChatGPT) was used solely for reference when recalling EF Core fluent API syntax and ULID conversion patterns; no AI‑generated code was copied directly into the solution. The README itself was drafted with the help of an AI assistant to ensure clarity and completeness.

Final thoughts

This solution demonstrates how to structure a .NET back‑end using Clean Architecture and CQRS. While it serves the recruitment task, it is far from production‑ready. Without error handling, event processing, tests, and deployment automation, it would not survive real‑world load. Those omissions are deliberate due to time constraints but would be mandatory for a robust service. Overall, the layered approach and separation of concerns provide a solid foundation for further development.